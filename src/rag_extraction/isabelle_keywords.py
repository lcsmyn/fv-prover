keywords = [
    # Theory Structure
    "theory",
    "imports",
    "begin",
    "end",
    "chapter",
    "section",
    "subsection",
    "subsubsection",
    "text",
    "txt",
    
    # Definitions and Declarations
    "definition",
    "fun",
    "function",
    "primrec",
    "datatype",
    "codatatype",
    "record",
    "type_synonym",
    "typedef",
    "consts",
    "axiomatization",
    "locale",
    "context",
    "interpretation",
    "sublocale",
    
    # Proof Commands
    "lemma",
    "theorem",
    "corollary",
    "proposition",
    "proof",
    "qed",
    "by",
    "apply",
    "done",
    "sorry",
    "oops",
    "show",
    "have",
    "obtain",
    "fix",
    "assume",
    "presume",
    "def",
    "let",
    "note",
    "then",
    "hence",
    "thus",
    "from",
    "with",
    "using",
    "unfolding",
    "case",
    "next",
    "moreover",
    "furthermore",
    "ultimately",
    "also",
    "finally",
    
    # Proof Methods
    "simp",
    "auto",
    "blast",
    "force",
    "fastforce",
    "clarify",
    "safe",
    "rule",
    "erule",
    "drule",
    "frule",
    "induct",
    "coinduct",
    "cases",
    "split",
    "subst",
    "unfold",
    "fold",
    "insert",
    "intro",
    "elim",
    "dest",
    "thin_tac",
    "rotate_tac",
    "rename_tac",
    "cut_tac",
    "subgoal_tac",
    "contradiction",
    "hypsubst",
    "atomize",
    "rulify",
    "normalize",
    "standard",
    "transfer",
    "lifting",
    
    # Attributes
    "simp",
    "intro",
    "elim",
    "dest",
    "rule",
    "symmetric",
    "OF",
    "of",
    "where",
    "THEN",
    "simplified",
    "unfolded",
    "folded",
    "atomized",
    "rulified",
    "standard",
    "no_vars",
    "consumes",
    "case_names",
    "case_conclusion",
    "induct",
    "coinduct",
    "split",
    "cong",
    "iff",
    
    # Logical Constants
    "True",
    "False",
    
    # Set Operations (text-based)
    "Un",
    "Int",
    "Pow",
    "UNION",
    "INTER",
    
    # Arithmetic Operators
    "div",
    "mod",
    "abs",
    "min",
    "max",
    "sum",
    "prod",
    
    # List Operations
    "set",
    "length",
    "rev",
    "hd",
    "tl",
    "take",
    "drop",
    "zip",
    "map",
    "filter",
    "foldr",
    "foldl",
    
    # Function Operations
    "o",
    "id",
    "inv",
    "inj",
    "surj",
    "bij",
    "fun_upd",
    "override_on",
    
    # Option Type
    "None",
    "Some",
    "the",
    "is_none",
    "map_option",
    
    # Conditionals and Bindings
    "if",
    "then",
    "else",
    "let",
    "in",
    "case",
    "of",
    
    # Basic Types
    "bool",
    "nat",
    "int",
    "real",
    "string",
    "unit",
    "list",
    "set",
    "option",
    
    # Type System
    "type_class",
    "instantiation",
    "instance",
    "class",
    "overloading",
    
    # Additional Tactics
    "assumption",
    "this",
    "goal_cases",
    "prefer",
    "defer",
    "back",
    "arith",
    "presburger",
    "algebra",
    "field",
    "ring",
    "eval",
    "normalization",
    "code_simp",
    "iff",
    "smt",
    "metis",
    "meson",
    "sledgehammer",
    "induct_tac",
    "case_tac",
    "induction",
    "coinduction",
    "strong_induction",
    "complete_induction",
    
    # Simplification Modifiers
    "add",
    "del",
    "only",
    "split",
    "cong",
    "flip",
    
    # Additional Keywords
    "LEAST",
    "GREATEST",
    "THE",
    "and",
    "is",
    "abbreviation",
    "hide_const",
    "hide_type",
    "hide_fact",
    "declare",
    "lemmas",
    "theorems",
    "named_theorems",
    "bundle",
    "unbundle",
    "include",
    "excluding",
    "fixes",
    "constrains",
    "assumes",
    "defines",
    "notes",
    "shows",
    "for",
    "structure",
    "morphism",
    "rewrites",
    "satisfies",
    "subgoal",
    "prefer",
    "defer",
    "back",
    "help",
    "find_theorems",
    "find_consts",
    "print_theorems",
    "print_facts",
    "print_methods",
    "print_attributes",
    "print_simpset",
    "print_claset",
    "print_syntax",
    "print_trans_rules",
    "print_cases",
    "print_induct_rules",
    "thm",
    "prop",
    "term",
    "typ",
    "ML",
    "ML_val",
    "ML_prf",
    "ML_command",
    "method_setup",
    "attribute_setup",
    "oracle",
    "judgment",
    "setup",
    "local_setup",
    "parse_translation",
    "print_translation",
    "typed_print_translation",
    "parse_ast_translation",
    "print_ast_translation",
    "translations",
    "no_translations",
    "syntax",
    "no_syntax",
    "nonterminal",
    "arities",
    "global_interpretation",
    "permanent_interpretation",
    "print_locale",
    "print_locales",
    "print_dependencies",
    "print_interps",
    "qualify",
    "quotient_type",
    "quotient_definition",
    "quotient_theorem",
    "lifting_forget",
    "lifting_update",
    "print_quotmaps",
    "print_quotients",
    "export_code",
    "code_abort",
    "code_datatype",
    "code_const",
    "code_type",
    "code_class",
    "code_instance",
    "code_reserved",
    "code_printing",
    "code_identifier",
    "code_reflect",
    "code_deps",
    "code_thms",
    "code_pred",
    "code_pred_intro",
    "inductive",
    "coinductive",
    "inductive_set",
    "coinductive_set",
    "inductive_cases",
    "coinductive_cases",
    "rep_datatype",
    "old_rep_datatype",
    "nominal_datatype",
    "nominal_function",
    "nominal_termination",
    "nominal_primrec",
    "nominal_inductive",
    "equivariance",
    "nominal_inductive2",
    "avoids",
    "permute_simp",
    "finite_guess",
    "fresh_guess",
    "perm_simp",
    "size_guess",
    "induct_scheme",
    "lexicographic_order",
    "size_change",
    "relation",
    "measure",
    "sequential",
    "partial_function",
    "tailrec",
    "domintros",
    "mono",
    "print_codesetup",
    "print_codeproc",
    "value",
    "values",
    "quickcheck",
    "quickcheck_params",
    "quickcheck_generator",
    "find_unused_assms",
    "nitpick",
    "nitpick_params",
    "sledgehammer_params",
    "try",
    "try0",
    "solve_direct",
    "quickcheck_narrowing",
    "refute",
    "refute_params",

    # Hacks
    "goal",
    "subgoal",
    "subgoals"

    # Text from escape sequences (\<...>)
    # "and",
    # "or",
    # "not",
    # "longrightarrow",
    # "longleftrightarrow",
    # "forall",
    # "exists",
    # "equiv",
    # "noteq",
    # "le",
    # "ge",
    # "in",
    # "notin",
    # "union",
    # "inter",
    # "subseteq",
    # "subset",
    # "supseteq",
    # "supset",
    # "emptyset",
    # "Union",
    # "Inter",
    # "circ",
    # "oplus",
    # "otimes",
    # "bottom",
    # "top",
    # "turnstile",
    # "Turnstile",
    # "lbrace",
    # "rbrace",
    # "lbrakk",
    # "rbrakk",
    # "langle",
    # "rangle",
    # "acute",
    # "star",
    # "bullet",
    # "cdot",
    # "times",
    # "div",
    # "plusminus",
    # "minusplus",
    # "infinity",
    # "partial",
    # "nabla",
    # "triangle",
    # "triangleq",
    # "parallel",
    # "perpendicular",
    # "angle",
    # "surd",
    # "sum",
    # "prod",
    # "integral",
    # "alpha",
    # "beta",
    # "gamma",
    # "delta",
    # "epsilon",
    # "zeta",
    # "eta",
    # "theta",
    # "iota",
    # "kappa",
    # "lambda",
    # "mu",
    # "nu",
    # "xi",
    # "pi",
    # "rho",
    # "sigma",
    # "tau",
    # "upsilon",
    # "phi",
    # "chi",
    # "psi",
    # "omega",
    # "Gamma",
    # "Delta",
    # "Theta",
    # "Lambda",
    # "Xi",
    # "Pi",
    # "Sigma",
    # "Upsilon",
    # "Phi",
    # "Psi",
    # "Omega",
    # "sub",
    # "sup",
    # "bold",
    # "emph",
    # "space",
    # "newline",
    # "tab"
]